<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inteligencia Artificial</title>
    <link href="general.css" rel="stylesheet" type="text/css" />
</head>
<body>
    <div class="container">
        <h1>Ciberseguridad - Computación en la Nube - Inteligencia Artificial</h1>
        <h2>Clase 15 de agosto del 2024</h2>
        <section>
            <h2>Ciberseguridad</h2>
            <p>
                La ciberseguridad es fundamental para proteger sistemas informáticos contra ataques y accesos no autorizados. 
                Incluye la implementación de medidas de seguridad como el cifrado, las autenticaciones robustas y la protección contra malware. 
                Además, se enfoca en la detección y respuesta a incidentes, así como en la capacitación de usuarios para evitar riesgos.
            </p>
            <br>
            <p>
                La ciberseguridad también abarca el cumplimiento de normativas y estándares internacionales para garantizar la seguridad 
                de los datos y la privacidad de los usuarios. Es un campo en constante evolución, dado el crecimiento de las amenazas y 
                vulnerabilidades tecnológicas.
            </p>
        </section>
        <hr>
        <section>
            <h2>Computación en la Nube</h2>
            <p>
                La computación en la nube proporciona recursos de TI a través de internet, permitiendo a las empresas y usuarios 
                utilizar servidores, almacenamiento y aplicaciones sin necesidad de infraestructura física propia. 
                Los principales modelos de servicio son IaaS (Infraestructura como Servicio), PaaS (Plataforma como Servicio) y SaaS 
                (Software como Servicio).
            </p>
            <p>
                Entre sus beneficios se incluyen la escalabilidad, la reducción de costos operativos y la flexibilidad en la gestión 
                de recursos. Los principales proveedores de servicios en la nube como Amazon Web Services (AWS), Microsoft Azure y 
                Google Cloud Platform ofrecen soluciones adaptadas a diferentes necesidades empresariales.
            </p>
        </section>
        <hr>
        <section>
            <h2>Inteligencia Artificial</h2>
            <p>
                La inteligencia artificial (IA) se centra en desarrollar sistemas que imitan la inteligencia humana para realizar 
                tareas como el reconocimiento de patrones, la toma de decisiones y el aprendizaje automático. 
                La IA se divide en dos categorías principales: IA débil, que se especializa en tareas específicas, y IA fuerte, 
                que aspira a tener una comprensión y razonamiento general similar al humano.
            </p>
            <p>
                La IA está revolucionando diversas industrias al automatizar procesos, mejorar la eficiencia operativa y permitir 
                el análisis avanzado de grandes volúmenes de datos. Aplicaciones comunes incluyen asistentes virtuales, sistemas de 
                recomendación y vehículos autónomos.
            </p>
        </section>
        <section>
            <h2>Clase 29 de agosto del 2024</h2>
            <h3>Ejercicio colab</h3>
            <p>
                <a href="https://colab.research.google.com/drive/1hIzOmIc8D0PZdSveYtQh3N4HuUes-c8v#scrollTo=5T50oopj5XtI">LINK DEL TRABAJO EN LINEA</a>
            </p>
        </section>
        <section>
            <div style="text-align: center; color:white"><h2>TABLA COMPARATIVA PUNTO 3 PARCIAL</h2></div>
            <div style="text-align: center; background-color: #606060; color:white"><h3>Comparacion - DFS</h3></div>
            <hr>
            <div style="width: 100%;">
                <table style="width: 100%;" border="5px">
                    <thead>
                        <tr>
                            <th>Laberinto 1</th>
                            <th>Resultado</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="text-align: center;"><img src="imagenes/Laberinto1_DFS.png" width="400px"></td>
                            <td style="text-align: center;"><img src="imagenes/Laberinto1S_DFS.png" width="200px"></td>
                        </tr>
                    </tbody>
                </table>
                <br>
                <table style="width: 100%;" border="5px">
                    <thead>
                        <tr>
                            <th>Laberinto 2</th>
                            <th>Resultado</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="text-align: center;"><img src="imagenes/Laberinto2_DFS.png" width="400px"></td>
                            <td style="text-align: center;"><img src="imagenes/Laberinto2S_DFS.png" width="200px"></td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>
        <section>
            <div style="text-align: center; background-color: #606060; color:white"><h3>Comparacion - BFS</h3></div>
            <hr>
            <div style="width: 100%;">
                <table style="width: 100%;" border="5px">
                    <thead>
                        <tr>
                            <th>Laberinto 1</th>
                            <th>Resultado</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="text-align: center;"><img src="imagenes/Laberinto1_BFS.png" width="400px"></td>
                            <td style="text-align: center;"><img src="imagenes/Laberinto1S_BFS.png" width="200px"></td>
                        </tr>
                    </tbody>
                </table>
                <br>
                <table style="width: 100%;" border="5px">
                    <thead>
                        <tr>
                            <th>Laberinto 2</th>
                            <th>Resultado</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="text-align: center;"><img src="imagenes/Laberinto2_BFS.png" width="400px"></td>
                            <td style="text-align: center;"><img src="imagenes/Laberinto2S_BFS.png" width="200px"></td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>
        <section>
            <h3><b>PARCIAL 1</b> - Punto 4</h3>
            <hr>
            <div style="width: 100%;">
                <p>
                    celsius = np.array([-40, -10, 0, 8, 15, 22, 38], dtype=float)  / / / Datos de entrada en grados Celsius <br>
                    fahrenheit = np.array([-40, 14, 32, 46, 59, 72, 100], dtype=float)  / / / Datos de salida en grados Fahrenheit<br>
                    <br>
                    oculta1 = tf.keras.layers.Dense(units=3, input_shape=[1])  / / / Capa oculta 1 con 3 neuronas, entrada de tamaño 1<br>
                    oculta2 = tf.keras.layers.Dense(units=3)  / / / Capa oculta 2 con 3 neuronas<br>
                    salida = tf.keras.layers.Dense(units=1)  / / / Capa de salida con 1 neurona<br>
                    <br>
                    modelo = tf.keras.Sequential([oculta1, oculta2, salida])  / / / Modelo secuencial con 2 capas ocultas y 1 de salida<br>
                    <br>
                    modelo.compile(<br>
                        optimizer=tf.keras.optimizers.Adam(0.1),  / / / Optimizador Adam con tasa de aprendizaje 0.1<br>
                        loss='mean_squared_error'  / / / Función de pérdida: error cuadrático medio<br>
                    )<br>

                    print("Comenzando entrenamiento...")<br>
                    historial = modelo.fit(celsius, fahrenheit, epochs=1000, verbose=False)  / / / Entrena el modelo durante 1000 épocas<br>
                    print("Modelo entrenado!")<br>
                    <br>
                    import matplotlib.pyplot as plt<br>
                    plt.xlabel("/ / / Epoca")<br>
                    plt.ylabel("Magnitud de pérdida")<br>
                    plt.plot(historial.history["loss"])  / / / Gráfica de la pérdida a lo largo de las épocas<br>
                    <br>
                    print("Hagamos una predicción!")<br>
                    resultado = modelo.predict([100.0])  / / / Realiza una predicción para 100 grados Celsius<br>
                    print("El resultado es " + str(resultado) + " fahrenheit!")<br>
                    <br>
                    print("Variables internas del modelo")<br>
                    print(oculta1.get_weights())  / / / Muestra los pesos de la primera capa oculta<br>
                    print(oculta2.get_weights())  / / / Muestra los pesos de la segunda capa oculta<br>
                    print(salida.get_weights())   / / / Muestra los pesos de la capa de salida<br>
                </p>
            </div>
        </section>
        <section>
            <h3><b>PARCIAL 2</b> - Punto 5 </h3>
            <hr>
            <div style="width: 100%;">
                <h2>Explicacion funcionamiento del codigo proporcionado</h2>
                <p style="background-color: #606060; padding:10px; border-radius: 5px; color: white;">
                    Este código define una serie de clases para representar y evaluar sentencias lógicas proposicionales y un algoritmo para la 
                    verificación de modelos. 
                    La clase base Sentence proporciona métodos comunes para evaluar una fórmula lógica, 
                    obtener su representación en forma de cadena y extraer los símbolos utilizados. 
                    Las clases derivadas como Symbol, Not, And, Or, Implication y Biconditional representan 
                    diferentes operadores lógicos y definen cómo se evalúan y manipulan esas sentencias en un modelo, 
                    que asigna valores de verdad a los símbolos lógicos. 
                    La función principal, model_check, verifica si una base de conocimiento lógica implica una consulta dada, 
                    probando todas las combinaciones posibles de asignaciones de verdad para los símbolos. 
                    Esto se realiza mediante la función auxiliar check_all, 
                    que evalúa todas las posibles configuraciones del modelo para determinar si la consulta es verdadera en todos los 
                    casos en los que la base de conocimiento también lo es. 
                    El código es útil para modelar y evaluar proposiciones lógicas, comprobando si un conjunto de afirmaciones lógicas 
                    implica una conclusión específica.
                </p>
                <br>
                <h3>Codigo:</h3>
                <p>
                    import itertools<br> 
                    <br>
                    <br>
                    class Sentence():<br>
                        """<br>
                        Clase base para representar una oración lógica.<br>
                        """<br>
                        <br>
                        def evaluate(self, model):<br>
                            """<br>
                            Evalúa la oración lógica utilizando un modelo.<br>
                            En este caso, es un método abstracto que será implementado en clases derivadas.<br>
                            """<br>
                            raise Exception("nada que evaluar")<br>
                            <br>
                        def formula(self):<br>
                            """<br>
                            Devuelve una representación de la fórmula lógica en forma de cadena de texto.<br>
                            """<br>
                            return ""<br>
                            <br>
                        def symbols(self):<br>
                            """<br>
                            Devuelve un conjunto de todos los símbolos presentes en la oración lógica.<br>
                            """<br>
                            return set()<br>
                            <br>
                        @classmethod<br>
                        def validate(cls, sentence):<br>
                            """<br>
                            Valida si un objeto es una instancia de la clase Sentence.<br>
                            """<br>
                            if not isinstance(sentence, Sentence):<br>
                                raise TypeError("debe ser una oración lógica")<br>
                                <br>
                        @classmethod<br>
                        def parenthesize(cls, s):<br>
                            """<br>
                            Coloca paréntesis en una expresión si no los tiene ya.<br>
                            """<br>
                            def balanced(s):<br>
                                """<br>
                                Verifica si una cadena tiene paréntesis balanceados.<br>
                                """<br>
                                count = 0<br>
                                for c in s:<br>
                                    if c == "(":<br>
                                        count += 1<br>
                                    elif c == ")":<br>
                                        if count <= 0:<br>
                                            return False<br>
                                        count -= 1<br>
                                return count == 0<br>
                                <br>
                            if not len(s) or s.isalpha() or (<br>
                                s[0] == "(" and s[-1] == ")" and balanced(s[1:-1])<br>
                            ):<br>
                                return s<br>
                            else:<br>
                                return f"({s})"<br>
                                <br>
                                <br>
                    class Symbol(Sentence):<br>
                        """<br>
                        Representa un símbolo lógico.<br>
                        """<br>
                        <br>
                        def _init_(self, name):<br>
                            self.name = name<br>
                            <br>
                        def _eq_(self, other):<br>
                            return isinstance(other, Symbol) and self.name == other.name<br>
                            <br>
                        def _hash_(self):<br>
                            return hash(("symbol", self.name))<br>
                            <br>
                        def _repr_(self):<br>
                            return self.name<br>
                            <br>
                        def evaluate(self, model):<br>
                            """<br>
                            Evalúa el valor del símbolo en un modelo dado.<br>
                            """<br>
                            try:<br>
                                return bool(model[self.name])<br>
                            except KeyError:<br>
                                raise EvaluationException(f"variable {self.name} no está en el modelo")<br>
                                <br>
                        def formula(self):<br>
                            return self.name<br>
                            <br>
                        def symbols(self):<br>
                            """<br>
                            Devuelve el conjunto que contiene solo este símbolo.<br>
                            """<br>
                            return {self.name}<br>
                            <br>
                            <br>
                    class Not(Sentence):<br>
                        """<br>
                        Representa una negación lógica.<br>
                        """<br>
                        def _init_(self, operand):<br>
                            Sentence.validate(operand)<br>
                            self.operand = operand<br>
                            <br>
                        def _eq_(self, other):<br>
                            return isinstance(other, Not) and self.operand == other.operand<br>
                            <br>
                        def _hash_(self):<br>
                            return hash(("not", hash(self.operand)))<br>
                            <br>
                        def _repr_(self):<br>
                            return f"Not({self.operand})"<br>
                            <br>
                        def evaluate(self, model):<br>
                            """<br>
                            Evalúa la negación, invirtiendo el valor del operando.<br>
                            """<br>
                            return not self.operand.evaluate(model)<br>
                            <br>
                        def formula(self):<br>
                            return "¬" + Sentence.parenthesize(self.operand.formula())<br>
                            <br>
                        def symbols(self):<br>
                            return self.operand.symbols()<br>
                            <br>
                            <br>
                    class And(Sentence):<br>
                        """<br>
                        Representa una conjunción lógica (Y).<br>
                        """<br>
                        def _init_(self, *conjuncts):<br>
                            for conjunct in conjuncts:<br>
                                Sentence.validate(conjunct)<br>
                            self.conjuncts = list(conjuncts)<br>
                            <br>
                        def _eq_(self, other):<br>
                            return isinstance(other, And) and self.conjuncts == other.conjuncts<br>
                            <br>
                        def _hash_(self):<br>
                            return hash(<br>
                                ("and", tuple(hash(conjunct) for conjunct in self.conjuncts))<br>
                            )<br>
                            <br>
                        def _repr_(self):<br>
                            conjunctions = ", ".join(<br>
                                [str(conjunct) for conjunct in self.conjuncts]<br>
                            )<br>
                            return f"And({conjunctions})"<br>
                            <br>
                        def add(self, conjunct):<br>
                            """<br>
                            Añade un nuevo conjunción a la lista.<br>
                            """<br>
                            Sentence.validate(conjunct)<br>
                            self.conjuncts.append(conjunct)<br>
                            <br>
                        def evaluate(self, model):<br>
                            """<br>
                            Evalúa si todas las conjunciones son verdaderas.<br>
                            """<br>
                            return all(conjunct.evaluate(model) for conjunct in self.conjuncts)<br>
                            <br>
                        def formula(self):<br>
                            """<br>
                            Devuelve la fórmula de la conjunción.<br>
                            """<br>
                            if len(self.conjuncts) == 1:<br>
                                return self.conjuncts[0].formula()<br>
                            return " ∧ ".join([Sentence.parenthesize(conjunct.formula())<br>
                                            for conjunct in self.conjuncts])<br>
                                            <br>
                        def symbols(self):<br>
                            return set.union(*[conjunct.symbols() for conjunct in self.conjuncts])<br>
                            <br>
                            <br>
                    class Or(Sentence):<br>
                        """<br>
                        Representa una disyunción lógica (O).<br>
                        """<br>
                        def _init_(self, *disjuncts):<br>
                            for disjunct in disjuncts:<br>
                                Sentence.validate(disjunct)<br>
                            self.disjuncts = list(disjuncts)<br>
                            <br>
                        def _eq_(self, other):<br>
                            return isinstance(other, Or) and self.disjuncts == other.disjuncts<br>
                            <br>
                        def _hash_(self):<br>
                            return hash(<br>
                                ("or", tuple(hash(disjunct) for disjunct in self.disjuncts))<br>
                            )<br>
                            <br>
                        def _repr_(self):<br>
                            disjuncts = ", ".join([str(disjunct) for disjunct in self.disjuncts])<br>
                            return f"Or({disjuncts})"<br>
                            <br>
                        def evaluate(self, model):<br>
                            """<br>
                            Evalúa si al menos una de las disyunciones es verdadera.<br>
                            """<br>
                            return any(disjunct.evaluate(model) for disjunct in self.disjuncts)<br>
                            <br>
                        def formula(self):<br>
                            """<br>
                            Devuelve la fórmula de la disyunción.<br>
                            """<br>
                            if len(self.disjuncts) == 1:<br>
                                return self.disjuncts[0].formula()<br>
                            return " ∨  ".join([Sentence.parenthesize(disjunct.formula())<br>
                                                for disjunct in self.disjuncts])<br>
                                                <br>
                        def symbols(self):<br>
                            return set.union(*[disjunct.symbols() for disjunct in self.disjuncts])<br>
                            <br>
                            <br>
                    class Implication(Sentence):<br>
                        """<br>
                        Representa una implicación lógica (si... entonces...).<br>
                        """<br>
                        def _init_(self, antecedent, consequent):<br>
                            Sentence.validate(antecedent)<br>
                            Sentence.validate(consequent)<br>
                            self.antecedent = antecedent<br>
                            self.consequent = consequent<br>
                            <br>
                        def _eq_(self, other):<br>
                            return (isinstance(other, Implication)<br>
                                    and self.antecedent == other.antecedent<br>
                                    and self.consequent == other.consequent)<br>
                                    <br>
                        def _hash_(self):<br>
                            return hash(("implies", hash(self.antecedent), hash(self.consequent)))<br>
                            <br>
                        def _repr_(self):<br>
                            return f"Implication({self.antecedent}, {self.consequent})"<br>
                            <br>
                        def evaluate(self, model):<br>
                            """<br>
                            Evalúa la implicación.<br>
                            """<br>
                            return ((not self.antecedent.evaluate(model))<br>
                                    or self.consequent.evaluate(model))<br>
                                    <br>
                        def formula(self):<br>
                            antecedent = Sentence.parenthesize(self.antecedent.formula())<br>
                            consequent = Sentence.parenthesize(self.consequent.formula())<br>
                            return f"{antecedent} => {consequent}"<br>
                            <br>
                        def symbols(self):<br>
                            return set.union(self.antecedent.symbols(), self.consequent.symbols())<br>
                            <br>
                            <br>
                    class Biconditional(Sentence):<br>
                        """<br>
                        Representa una bicondicional lógica (si y solo si).<br>
                        """<br>
                        def _init_(self, left, right):<br>
                            Sentence.validate(left)<br>
                            Sentence.validate(right)<br>
                            self.left = left<br>
                            self.right = right<br>
                            <br>
                        def _eq_(self, other):<br>
                            return (isinstance(other, Biconditional)<br>
                                    and self.left == other.left<br>
                                    and self.right == other.right)<br>
                                    <br>
                        def _hash_(self):<br>
                            return hash(("biconditional", hash(self.left), hash(self.right)))<br>
                            <br>
                        def _repr_(self):<br>
                            return f"Biconditional({self.left}, {self.right})"<br>
                            <br>
                        def evaluate(self, model):<br>
                            """<br>
                            Evalúa si ambas proposiciones tienen el mismo valor de verdad.<br>
                            """<br>
                            return ((self.left.evaluate(model)<br>
                                    and self.right.evaluate(model))<br>
                                    or (not self.left.evaluate(model)<br>
                                        and not self.right.evaluate(model)))<br>
                                        <br>
                        def formula(self):<br>
                            left = Sentence.parenthesize(str(self.left))<br>
                            right = Sentence.parenthesize(str(self.right))<br>
                            return f"{left} <=> {right}"<br>
                            <br>
                        def symbols(self):<br>
                            return set.union(self.left.symbols(), self.right.symbols())<br>
                            <br>
                            <br>
                    def model_check(knowledge, query):<br>
                        """<br>
                        Verifica si la base de conocimiento implica una consulta.<br>
                        """<br>
                        <br>
                        def check_all(knowledge, query, symbols, model):<br>
                            """<br>
                            Verifica si la base de conocimiento implica la consulta en un modelo dado.<br>
                            """<br>
                            <br>
                            # Si el modelo tiene una asignación para cada símbolo<br>
                            if not symbols:<br>
                            <br>
                                # Si la base de conocimiento es verdadera en el modelo, entonces la consulta también debe ser verdadera<br>
                                if knowledge.evaluate(model):<br>
                                    return query.evaluate(model)<br>
                                return True<br>
                            else:<br>
                            <br>
                                # Elige uno de los símbolos restantes no utilizados<br>
                                remaining = symbols.copy()<br>
                                p = remaining.pop()<br>
                                <br>
                                # Crea un modelo donde el símbolo es verdadero<br>
                                model_true = model.copy<br>
                                model_true[p] = True<br>
                                <br>
                                # Create a model where the symbol is false<br>
                                model_false = model.copy()<br>
                                model_false[p] = False<br>
                                <br>
                                # Ensure entailment holds in both models<br>
                                return (check_all(knowledge, query, remaining, model_true) and<br>
                                        check_all(knowledge, query, remaining, model_false))<br>
                                        <br>
                        # Get all symbols in both knowledge and query<br>
                        symbols = set.union(knowledge.symbols(), query.symbols())<br>
                        <br>
                        # Check that knowledge entails query<br>
                        return check_all(knowledge, query, symbols, dict())<br>
                        <br>
                </p>
            </div>
        </section>
        <section>
            <h3><b>PARCIAL 2</b> - Punto 5 </h3>
            <hr>
            <div class="width: 100%;">
                <img src="imagenes/punto6Parcial2.png" width="100%" alt="">
            </div>
        </section>
    </div>
</body>
</html>